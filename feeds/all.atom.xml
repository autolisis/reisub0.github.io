<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Digressions - A blog</title><link href="https://reisub0.github.io/" rel="alternate"></link><link href="https://reisub0.github.io/feeds/all.atom.xml" rel="self"></link><id>https://reisub0.github.io/</id><updated>2020-10-10T00:00:00+05:30</updated><subtitle>Govind KP</subtitle><entry><title>Fractal Learning</title><link href="https://reisub0.github.io/fractal-learning.html" rel="alternate"></link><published>2020-10-10T00:00:00+05:30</published><updated>2020-10-10T00:00:00+05:30</updated><author><name>Govind KP</name></author><id>tag:reisub0.github.io,2020-10-10:/fractal-learning.html</id><summary type="html">&lt;p&gt;&lt;img alt="tree" src="https://reisub0.github.io/images/tree-small.gif"&gt;&lt;/p&gt;
&lt;h4&gt;Part 1 - Complexity&lt;/h4&gt;
&lt;p&gt;This world is a complex, interconnected web of systems. We've tried to make sense of this by creating various (seemingly-unrelated) disciplines. With the huge number of disciplines, I think you'll agree with me when I say that it's impossible for any one person to be an expert â€¦&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="tree" src="https://reisub0.github.io/images/tree-small.gif"&gt;&lt;/p&gt;
&lt;h4&gt;Part 1 - Complexity&lt;/h4&gt;
&lt;p&gt;This world is a complex, interconnected web of systems. We've tried to make sense of this by creating various (seemingly-unrelated) disciplines. With the huge number of disciplines, I think you'll agree with me when I say that it's impossible for any one person to be an expert in all of these fields.&lt;/p&gt;
&lt;p&gt;It's turtles all the way down, however, and even as you go deeper into a field, there's still so much complexity that you would despair at the idea of ever really understanding anything even within the confines of one specific field.&lt;/p&gt;
&lt;p&gt;Most fields seem to exhibit a fractal pattern. By this, I mean that the more you try to &lt;em&gt;zoom in&lt;/em&gt; onto a specific aspect of a system, the more detail is revealed. The same is true whether you're talking about economics or physics or biology. A whole new world of detail is revealed at all the different levels.&lt;/p&gt;
&lt;p&gt;Of course, when confronted with complexity, our first instinct is to &lt;em&gt;reduce&lt;/em&gt; and to treat these in isolation, and we've tried to come to terms with the complexity within fields by creating &lt;strong&gt;specializations&lt;/strong&gt;, which are essentially sub-fields. &lt;/p&gt;
&lt;p&gt;This is why a microbiologist seems to speak a completely different language from an ecologist. This might make you wonder whether the two fields are even related; one could argue that they both view the world through a radically different set of lenses.&lt;/p&gt;
&lt;p&gt;As human knowledge progresses and we're able to understand systems at different levels, we're continuously spawning newer and newer specializations and hyperspecializations.&lt;/p&gt;
&lt;p&gt;Nowhere is this concept clearer than in computer science where incredibly complex systems have been built to deliver cat videos to your screen. There's nothing special about my choice of computer science here, as I'm sure there are similar levels of complexity lurking beneath the surface of any domain.&lt;/p&gt;
&lt;p&gt;You could spend years and years in deep study and you still wouldn't really fully &lt;em&gt;get&lt;/em&gt; how a computer worked. There would always be gaps in your knowledge. Even behind something as seemingly simple as allowing you to read these words on your screen, there is so much hidden complexity. There are towers and towers of abstractions that enable this to happen:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Your CPU (essentially a tiny piece of silicon that can't do much but add two numbers together) executed a few million instructions during the time you were reading this sentence. Welcome to Computer Architecture!&lt;/li&gt;
&lt;li&gt;These instructions are in most cases not understandable by a human. So we invented a &lt;em&gt;high-level language&lt;/em&gt; and wrote another software to convert this high level language into the instructions. Welcome to Compilers!&lt;/li&gt;
&lt;li&gt;There are multiple applications running on this system at the same time; somehow, a piece of code (the Operating System), managed to abstract all this away such that the applications are able to pretend that they're the only application running on the system. Similarly, there are other resources (RAM, files, I/O devices) that all need to be shared between the hundreds of programs running on your system. Welcome to Operating Systems!&lt;/li&gt;
&lt;li&gt;Your device doesn't exist in isolation. In fact, a lot of its capabilities arise in relation with other devices. Just for the purpose of loading this website and viewing it, it had to send signals out into the ether which somehow (like a labelled envelope) found its way to the right servers and then they responded back with the data you were requesting. Welcome to Networks!&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In fact, all of the cases above are huge simplifications. I haven't even begun scratching the surface. If you're curious to learn more, &lt;a href="https://github.com/alex/what-happens-when"&gt;look at how much detail&lt;/a&gt; is hidden behind a simple Google search.&lt;/p&gt;
&lt;p&gt;So how do you even begin to understand and make sense of things which seem to have so many interconnected pieces?&lt;/p&gt;
&lt;p&gt;A short digression here: there is a famous result in psychology about working memory (also called &lt;a href="https://en.wikipedia.org/wiki/The_Magical_Number_Seven,_Plus_or_Minus_Two"&gt;Miller's Law&lt;/a&gt;). It suggests that humans can, on average, hold about 7 objects in their short-term memory at one time. Basically, if you're playing around with concepts in your head and thinking about how things relate with one another, there seems to be a cognitive limit of about 7 items.&lt;/p&gt;
&lt;p&gt;Of course that is quite fuzzy and it is of course dangerous to generalize too much from any one result. However, I'd suggest that we can take away this lesson from Miller's Law: humans can't hold too many things in their head at the same time. Software systems are very complex beasts and it's beyond the scope of any person to hold in their head all the minute details of how something is working. &lt;/p&gt;
&lt;p&gt;This is where &lt;em&gt;Abstraction&lt;/em&gt; comes in. This is one of the fundamental building blocks of Computer Science, Engineering, and Problem Solving in general. Abstraction is when you squint your eyes and treat something as a &lt;em&gt;black box&lt;/em&gt;. You are temporarily choosing to not care about what's happening inside the black box because other details are more important. &lt;/p&gt;
&lt;p&gt;For an example of abstraction think about &lt;em&gt;interfaces&lt;/em&gt; to objects you commonly use. A car for example hides a lot of complicated circuitry and machinery, but at the end of the day, all you need to care about is the steering wheel and a couple of pedals. That's the abstract view of a car. I don't care how that car turns these inputs into the multiple complicated outputs of fuel intake, torque etc. I completely ignore that because it's not important to me. I just want to get from point A to point B and I just need to know how to use the interface of the car to achieve the goal.&lt;/p&gt;
&lt;p&gt;A well-designed interface (this is true of software interfaces too!) would allow you to focus on fewer aspects of the car and expend lesser &lt;em&gt;cognitive effort&lt;/em&gt; when driving the car; I'm talking about manual vs automatic vs self-driving cars. &lt;/p&gt;
&lt;p&gt;Sure, that's all well and good, but this article is about &lt;em&gt;Dealing with Complexity&lt;/em&gt;, not about &lt;em&gt;Pretending it doesn't exist&lt;/em&gt;. After all, someone does ultimately have to design and work with the underlying complexity (&lt;a href="https://en.wikipedia.org/wiki/Law_of_conservation_of_complexity"&gt;Tesler's Law&lt;/a&gt;). You'd be a terrible automobile engineer if you were only able to see a car as its interface!&lt;/p&gt;
&lt;p&gt;Things are even harder when you're a student and trying to learn more about a certain field you have no prior knowledge in; with so much to learn, how do you decide what is worth digging deeper into?&lt;/p&gt;
&lt;p&gt;So hold on to this idea of abstraction, and let's talk about Fractal Learning, which is the focus of this blog post.&lt;/p&gt;
&lt;h4&gt;Part 2 - Fractal Learning&lt;/h4&gt;
&lt;p&gt;Fractal learning is essentially a strategy used to make sense of complex systems without getting too lost in the details. It's about being in that Goldilocks zone of not wasting your time learning too much (you have other things to do) while at the same time getting an overall understanding of how things fit together.&lt;/p&gt;
&lt;p&gt;I first came across this concept in the excellent &lt;a href="https://intermezzos.github.io/book/second-edition/fractal-learning.html"&gt;IntermezzOS Book&lt;/a&gt;. It beautifully encapsulates the challenges of students and researchers working to make sense of complex systems:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It's impossible to learn everything at once. If you keep digging, you'll find more questions, and digging into those questions leads to more questions... at some point, you have to say "okay, I know enough about this for now, it's time to move on."&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Here's that picture of a tree again:&lt;/p&gt;
&lt;p&gt;&lt;img alt="tree" src="https://reisub0.github.io/images/tree.gif"&gt;&lt;/p&gt;
&lt;p&gt;Let's imagine that this tree represents your field of interest. Your job is to somehow navigate this tree (or a branch) and learn &lt;em&gt;everything&lt;/em&gt;. Now, clearly, learning everything isn't going to happen in this lifetime, but you still want to know enough to get a good idea of how everything fits together.&lt;/p&gt;
&lt;p&gt;How do you do it?&lt;/p&gt;
&lt;p&gt;Most people seem to follow one of two strategies - and these strategies come under the umbrella of &lt;em&gt;tree-traversal algorithms&lt;/em&gt; in computer science. &lt;/p&gt;
&lt;p&gt;Let's dig a bit deeper into both of these as they are relevant to the discussion.&lt;/p&gt;
&lt;p&gt;The first is depth-first search (I call it &lt;em&gt;falling down the rabbit hole&lt;/em&gt;). It's represented by this animation&lt;sup id="sf-fractal-learning-1-back"&gt;&lt;a href="#sf-fractal-learning-1" class="simple-footnote" title="Source"&gt;1&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;center&gt;&lt;img alt="dfs" src="https://reisub0.github.io/images/dfs.gif"&gt;&lt;/center&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;Here, you start at the root of the tree (represented by 1) and you keep going deeper and deeper along any one path. You stop when you can go no further and then try one of the other paths.&lt;/p&gt;
&lt;p&gt;To better visualize it, here is the same algorithm working to solve a maze&lt;sup id="sf-fractal-learning-2-back"&gt;&lt;a href="#sf-fractal-learning-2" class="simple-footnote" title="Source"&gt;2&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;center&gt;&lt;img alt="dfs" src="https://reisub0.github.io/images/dfsmaze.gif"&gt;&lt;/center&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;I hope you get why I called it falling down the rabbit hole; you're just digging deeper and deeper into a specific topic without really taking a step back to explore other related topics. This is a laser-focused strategy that focuses on exclusion. It's the equivalent of the child who keeps asking "Why?" for a specific topic until she can no longer get a meaningful answer. If someone followed only this strategy for learning about things, she would have very detailed and specific knowledge about that one thing but have absolutely no idea about even closely related things.&lt;/p&gt;
&lt;p&gt;Let's talk about the other strategy - breadth-first search (I call it &lt;em&gt;flooding&lt;/em&gt;):&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;center&gt;&lt;img alt="dfs" src="https://reisub0.github.io/images/bfs.gif"&gt;&lt;/center&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;This is the polar opposite of the previous approach. Here you are quite timid, and you never go more than one level at a time, and you make your way level-by-level.&lt;/p&gt;
&lt;p&gt;Here it is again, within the maze context&lt;sup id="sf-fractal-learning-3-back"&gt;&lt;a href="#sf-fractal-learning-3" class="simple-footnote" title="Source"&gt;3&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;center&gt;&lt;img alt="dfs" src="https://reisub0.github.io/images/bfsmaze.gif"&gt;&lt;/center&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;Again, I hope it makes sense why I called it flooding; it works similarly to how water slowly rises to flood an area. Here you dig very shallowly and take the time to understand the basics of everything before making your way deeper. This is focused on being inclusive and getting a sense of how everything fits together, even if it's not relevant. Someone who followed only this strategy would be a jack of all trades, he would know the fundamentals of everything; but like the figure of speech goes, he would be a master of none.&lt;/p&gt;
&lt;p&gt;So which should you follow: breadth-first or depth-first?&lt;/p&gt;
&lt;p&gt;Sadly, as with a lot of things in life, the answer is: it depends. You will have to use your judgment and intuition to decide which approach to use depending on the situation. Both approaches have their trade-offs.&lt;/p&gt;
&lt;p&gt;Of course, given enough time, both approaches would cover the entire tree. As we saw, both approaches managed to solve the maze.&lt;/p&gt;
&lt;p&gt;But we don't really have much time, do we?&lt;/p&gt;
&lt;p&gt;In the following examples (both of which are real-world scenarios), the above strategies are sub-optimal. You will have to use a combination of both, carefully using your judgment to pick which topics are worth exploring deeper, and which are only worth skimming through.&lt;/p&gt;
&lt;p&gt;When you are new to a field and trying to get an overall sense of how the field works, it might be a waste of time to fall down any rabbit holes as you don't have the experience to know which lines of questioning are relevant. So a breadth-centric approach might serve you well. In this case, you should form appropriate abstractions for the concepts you are encountering so that you can dig deeper into them later if you need.&lt;/p&gt;
&lt;p&gt;An example of this would be reading only the Wikipedia introductions for the topics you encounter while skimming through the rest of the article, while clicking through the links in the introduction for further exploration. Here, it's important to still pay some attention to the details so you can return to it later.&lt;/p&gt;
&lt;p&gt;On the other hand, let's say you are trying to find a solution to a specific problem that you are trying to solve. Here it might be wiser to follow a more depth-centric approach, using your intuition to guide you down relevant lines of questioning. Note that it's much better to already have an overall sense of how things work; otherwise, you wouldn't know where to start, and it would just be an undirected (and probably fruitless) search. Here, it would just be a distraction to think too much about the things you are encountering. It may save you some time to skim through the material and get an overall sense of how things work, in case you need it later. However, it is essential to stay on track and not lose sight of the specific thing you are trying to solve at that moment.&lt;/p&gt;
&lt;p&gt;An example of this would be trying to find a specific piece of information on Wikipedia. You would have a sort of tunnel vision: You know exactly what you want, and everything else is a mere distraction. Here, it is important to not get too hyper-focused and pay some attention to the overall context as well. Then, your understanding of the entire field grows, not just the specific part you are dealing with.&lt;/p&gt;
&lt;p&gt;Ultimately these two examples really serve to demonstrate what the topic of this blog post is about: Fractal learning.&lt;/p&gt;
&lt;p&gt;Fractal learning is ultimately about balance and flexibility. It's about:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;keeping the big picture in your mind even when digging into the details, whilst simultaneously&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;paying close attention to the details even when you are just skimming &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;choosing the appropriate level of abstraction for what you're trying to do, whilst simultaneously&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;zooming in and out of different levels of abstraction. &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It means that sometimes you choose to accept things the way things are without questioning deeper; and maybe later, you choose to dig deeper into those same assumptions.&lt;/p&gt;
&lt;p&gt;This might seem fundamentally to be quite contradictory. There's almost a very Zen aspect to it as it is not an easy or simple thing to do to make these trade-offs. Failure is inevitable and it is natural and expected that you sometimes you go too deeply into irrelevant details and too shallowly into the important details. But this &lt;em&gt;is&lt;/em&gt; definitely a skill that can be learned. In fact, It's not just a skill but a &lt;em&gt;meta-skill&lt;/em&gt; that would greatly increase the rate at which you learn all skills.&lt;/p&gt;
&lt;p&gt;I have seen a general tendency in myself to dig too deep into a topic early on and get lost in the maze. If you're like me, I hope this article encourages you to pause, take a step back, and think about the overall system every once in a while.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It's okay to not "fully" understand something before moving on, whatever that means. You'll get back to it. Sometimes, learning something else is more important than diving into every last detail.&lt;/p&gt;
&lt;/blockquote&gt;&lt;ol class="simple-footnotes"&gt;&lt;li id="sf-fractal-learning-1"&gt;&lt;a href="https://medium.com/@kenny.hom27/breadth-first-vs-depth-first-tree-traversal-in-javascript-48df2ebfc6d1"&gt;Source&lt;/a&gt; &lt;a href="#sf-fractal-learning-1-back" class="simple-footnote-back"&gt;â†©&lt;/a&gt;&lt;/li&gt;&lt;li id="sf-fractal-learning-2"&gt;&lt;a href="https://coderscat.com/depth-first-searchdfs-explained-with-visualization"&gt;Source&lt;/a&gt; &lt;a href="#sf-fractal-learning-2-back" class="simple-footnote-back"&gt;â†©&lt;/a&gt;&lt;/li&gt;&lt;li id="sf-fractal-learning-3"&gt;&lt;a href="https://coderscat.com/breadth-first-searchbfs-explained-with-visualization"&gt;Source&lt;/a&gt; &lt;a href="#sf-fractal-learning-3-back" class="simple-footnote-back"&gt;â†©&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;</content><category term="learning"></category><category term="learning"></category><category term="systems"></category></entry><entry><title>Writing Idiomatic Rust</title><link href="https://reisub0.github.io/writing-idiomatic-rust.html" rel="alternate"></link><published>2019-03-23T00:00:00+05:30</published><updated>2019-03-23T00:00:00+05:30</updated><author><name>Govind KP</name></author><id>tag:reisub0.github.io,2019-03-23:/writing-idiomatic-rust.html</id><summary type="html">&lt;p&gt;&lt;a href="https://www.rust-lang.org/"&gt;Rust&lt;/a&gt; is, in a word, beautiful. If I was allowed to use multiple words, I'd probably add explicit, safe, well-designed and multi-paradigm into the mix. The language provides immense freedom, but at times it becomes a bit &lt;em&gt;too&lt;/em&gt; liberating. &lt;/p&gt;
&lt;p&gt;You'd be restricting yourself if you simply thought of Rust as â€¦&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://www.rust-lang.org/"&gt;Rust&lt;/a&gt; is, in a word, beautiful. If I was allowed to use multiple words, I'd probably add explicit, safe, well-designed and multi-paradigm into the mix. The language provides immense freedom, but at times it becomes a bit &lt;em&gt;too&lt;/em&gt; liberating. &lt;/p&gt;
&lt;p&gt;You'd be restricting yourself if you simply thought of Rust as a better C, even though it is. Rust provides abstractions when you really need them, unlike C. There's a thoughtfully designed type system (which does get in your way at times, but the benefits far outweigh the costs). But again, you'd be restricting yourself if you thought of Rust as a less abstract Haskell with no GC, even though it is. You don't have to worry about monads or functors or their "purity". &lt;/p&gt;
&lt;p&gt;Rust is &lt;em&gt;multi-paradigm&lt;/em&gt;, meaning you (the programmer) have complete freedom to choose the best paradigm for the task. It is a crazy mishmash of the best features of many languages, and yet it manages to be so simple that &lt;a href="https://doc.rust-lang.org/reference/statements-and-expressions.html"&gt;everything is an expression&lt;/a&gt; with an elegant, consistent syntax. This means that you can write this (reading the &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; as similar to C):&lt;/p&gt;
&lt;div class="rust highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;greater&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;: &lt;span class="kt"&gt;i64&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;: &lt;span class="kt"&gt;i64&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-&amp;gt; &lt;span class="kt"&gt;i64&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;or this (similar to a ternary operator, no explicit return, the last expression in a function is considered to be the return):&lt;/p&gt;
&lt;div class="rust highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;greater&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;: &lt;span class="kt"&gt;i64&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;: &lt;span class="kt"&gt;i64&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-&amp;gt; &lt;span class="kt"&gt;i64&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;A casual reader might not appreciate the difference between the two. &lt;code&gt;return a&lt;/code&gt; is a expression. But adding the semicolon makes it a statement. Specifically, it makes it an &lt;a href="https://doc.rust-lang.org/reference/statements.html#expression-statements"&gt;ExpressionStatement&lt;/a&gt;. To make this clearer, take a look at this example, which is also valid Rust:&lt;/p&gt;
&lt;div class="rust highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;greater&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;: &lt;span class="kt"&gt;i64&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;: &lt;span class="kt"&gt;i64&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-&amp;gt; &lt;span class="kt"&gt;i64&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Of course, the second example is considered "idiomatic Rust", and I'm slowly coming to actually understand what that means. &lt;/p&gt;
&lt;p&gt;I've been working on a &lt;a href="https://github.com/reisub0/nzb"&gt;small project of mine (~600 LoC)&lt;/a&gt; which is a terminal app that provides a good front-end for the &lt;a href="https://nozbe.com/"&gt;Nozbe&lt;/a&gt; project management tool. My code is still far from idiomatic, and not very readable. But I've learned and tried to make it so. Rust has its own unique dialect with best practices and no-nos. Here's what I've found helpful (as a beginner) for navigating this space and writing idiomatic code:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Find popular &lt;a href="https://crates.io/"&gt;crates&lt;/a&gt; that have similar tags and categories as yours and go through the source, seeing how problems and patterns are solved&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The &lt;a href="https://github.com/trending/rust"&gt;Rust tag&lt;/a&gt; on Github usually has excellent examples of good code quality&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Check out the official sources: the &lt;a href="https://doc.rust-lang.org/book/"&gt;Rust book&lt;/a&gt;, the &lt;code&gt;std&lt;/code&gt; implementations and &lt;a href="https://doc.rust-lang.org/"&gt;docs&lt;/a&gt; set the standard to aspire towards&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://doc.rust-lang.org/rust-by-example/"&gt;Rust by example&lt;/a&gt; is such a good resource that I have to mention it separately&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Prioritize code that is elegant and concise&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The &lt;code&gt;Result&lt;/code&gt; and &lt;code&gt;Option&lt;/code&gt; types are your friends, use them everywhere&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There's a lot of beauty in Rust, and as a language, it enables programmers to express their thoughts in the most elegant way possible. It is outstanding in the faith it has in programmers and the freedom that it provides (at &lt;a href="https://ruudvanasseldonk.com/2016/11/30/zero-cost-abstractions"&gt;zero cost&lt;/a&gt;). I hope that this article helps you in expressing your own thoughts better.&lt;/p&gt;
&lt;p&gt;Good luck.&lt;/p&gt;</content><category term="tech"></category></entry><entry><title>Using Rust for the 'Blink' program on the Raspberry Pi 3</title><link href="https://reisub0.github.io/using-rust-for-the-blink-program-on-the-raspberry-pi-3.html" rel="alternate"></link><published>2019-01-11T00:00:00+05:30</published><updated>2019-01-11T00:00:00+05:30</updated><author><name>Govind KP</name></author><id>tag:reisub0.github.io,2019-01-11:/using-rust-for-the-blink-program-on-the-raspberry-pi-3.html</id><summary type="html">&lt;p&gt;Rust is an amazing systems-level programming language that has &lt;em&gt;safety&lt;/em&gt; as one of its top design goals, along with &lt;em&gt;concurrency&lt;/em&gt; and &lt;em&gt;performance&lt;/em&gt;. It is systems-level, meaning you can call assembly code within it, or work with raw memory contents. Rust feels and writes like a high level language, but it â€¦&lt;/p&gt;</summary><content type="html">&lt;p&gt;Rust is an amazing systems-level programming language that has &lt;em&gt;safety&lt;/em&gt; as one of its top design goals, along with &lt;em&gt;concurrency&lt;/em&gt; and &lt;em&gt;performance&lt;/em&gt;. It is systems-level, meaning you can call assembly code within it, or work with raw memory contents. Rust feels and writes like a high level language, but it has all the powers of a lower level one like C. However, anything that has the potential to blow up in your face, like dereferencing a pointer that could be NULL, has to be wrapped up in &lt;code&gt;unsafe&lt;/code&gt; code blocks, meaning you're telling the compiler that you know what you're doing. Note that this does &lt;strong&gt;not&lt;/strong&gt; turn off the borrow checker.&lt;/p&gt;
&lt;p&gt;Rust is heavily influenced by the likes of pure functional languages like Haskell while being pragmatic enough to not include a GC which would make it impractical for systems-level work. It borrows from the best aspects of these languages to create what is, in my opinion, the best language for low level work. The upfront cost and time investment for carefully defining your types and what data you're going to be working with might seem like too much of a price to pay compared to the 'Wild West' attitude of C. But the compiler really has got your back and you can be reasonably certain your code isn't going to blow up at runtime once it has passed the rigorous standards of the compiler. This does mean you will be fighting with the compiler a bit to get your code past it but it is worth it.&lt;/p&gt;
&lt;p&gt;Especially when you're talking about bare metal programming where there's no debugging other than print statements (if you're lucky), it's almost impossible to know if the program you're writing in C is going to do what it's expected to do. Rust forces you to think about your code and your types and think about your error cases a bit more carefully. Once you've made it past the borrow checker and your code successfully compiles in Rust, you've also made it past so many pitfalls that the same code in C would have fallen into at runtime.&lt;/p&gt;
&lt;p&gt;Rust is also strongly typed compared to weakly typed C. This means there's no unseen conversions to and from types. This means that another class of common errors from C are eliminated.&lt;/p&gt;
&lt;p&gt;Enough ranting about programming languages, let's try to make something useful in Rust.&lt;/p&gt;
&lt;p&gt;Here's what we're going to do: The Raspberry Pi 3 has an on-board Green LED that's usually mapped to SD Card activity by the operating system. Since we are going to implement the kernel, we're instead going to blink the so called &lt;code&gt;ACT&lt;/code&gt; LED at regular intervals. And we're going to do this all from pure Rust.&lt;/p&gt;
&lt;p&gt;To achieve this, you need a working knowledge of writing to memory mapped registers. Instead of mucking about with bitwise operators and shifts, we're going to rely on Rust's amazing macro and type support, and use the &lt;code&gt;register&lt;/code&gt; crate to define the layout of our registers in memory. This enables us to write much more readable code. For similar code on how to define register contents, look around the excellent &lt;a href="https://github.com/rust-embedded/rust-raspi3-tutorial"&gt;rust-raspi3-tutorial&lt;/a&gt; repository.&lt;/p&gt;
&lt;p&gt;You will likely need to be &lt;em&gt;ARMed&lt;/em&gt; with the &lt;a href="https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf"&gt;BCM2837 ARM Peripherals Manual&lt;/a&gt;. The link is for the BCM2835. There is no difference between the two, except for a different base address. You'll be interested in Chapter 6: GPIO. Look around for what registers you need to modify to achieve what you want.&lt;/p&gt;
&lt;p&gt;Some caveats to remember:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The base address is 0x3F00_0000 as opposed to the 0x7E00_0000 on the manual&lt;/li&gt;
&lt;li&gt;GPIO 29 is mapped to the ACT LED on the RPI 3B+.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you're stuck at any point, you may look at &lt;a href="https://github.com/reisub0/rust-raspi3-tutorial/tree/master/led"&gt;my code&lt;/a&gt; for the same.&lt;/p&gt;
&lt;p&gt;Good luck.&lt;/p&gt;</content><category term="tech"></category></entry><entry><title>Jumping into OS-Development with Raspberry Pi 3</title><link href="https://reisub0.github.io/jumping-into-os-development-with-raspberry-pi-3.html" rel="alternate"></link><published>2018-12-17T00:00:00+05:30</published><updated>2018-12-17T00:00:00+05:30</updated><author><name>Govind KP</name></author><id>tag:reisub0.github.io,2018-12-17:/jumping-into-os-development-with-raspberry-pi-3.html</id><summary type="html">&lt;p&gt;This is just a quick-start guide on how to write a bare metal program for the Raspberry Pi 3. This is heavily based on the amazing &lt;a href="https://github.com/s-matyukevich/raspberry-pi-os"&gt;Raspberry Pi OS&lt;/a&gt; which details how to develop your own OS (in turn inspired heavily by the Linux kernel)&lt;/p&gt;
&lt;p&gt;However, a shortcoming of that â€¦&lt;/p&gt;</summary><content type="html">&lt;p&gt;This is just a quick-start guide on how to write a bare metal program for the Raspberry Pi 3. This is heavily based on the amazing &lt;a href="https://github.com/s-matyukevich/raspberry-pi-os"&gt;Raspberry Pi OS&lt;/a&gt; which details how to develop your own OS (in turn inspired heavily by the Linux kernel)&lt;/p&gt;
&lt;p&gt;However, a shortcoming of that tutorial are the &lt;a href="https://github.com/s-matyukevich/raspberry-pi-os/blob/master/docs/Prerequisites.md"&gt;prerequisites&lt;/a&gt;. A Pi 3 is not &lt;em&gt;that&lt;/em&gt; cheap and USB-to-TTL converters, though much cheaper are still an additional piece of hardware you must obtain.&lt;/p&gt;
&lt;p&gt;There is a much cheaper alternative - QEMU. QEMU has had direct support for the Pi 3 since April 2018 through the &lt;code&gt;-M&lt;/code&gt; flag.&lt;/p&gt;
&lt;p&gt;The code (Lesson 1 from the tutorial) is a simple "Hello world" program that is run completely independently of any library routines. It uses nothing but writing values on registers to achieve this goal.&lt;/p&gt;
&lt;p&gt;This guide is quickly going to run you through how you can run the code from the tutorial on QEMU. This assumes you are using a Linux distribution (Arch Linux) for brevity's sake.&lt;/p&gt;
&lt;p&gt;First, install the GNU CC Cross compiler for &lt;code&gt;aarch64&lt;/code&gt;. The Raspberry Pi 3 has an ARM64 SoC. A cross-compiler builds code meant for another platform. Your system (which almost certainly has an x86_64 processor will normally compile code for itself with &lt;code&gt;gcc&lt;/code&gt;)&lt;/p&gt;
&lt;div class="bash highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;pacman -S aarch64-linux-gnu-gcc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now, we install QEMU, and RPI3 support for it.&lt;/p&gt;
&lt;div class="bash highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;pacman -S qemu qemu-arch-extra
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;For our source code, we clone the RPI OS repository,&lt;/p&gt;
&lt;div class="bash highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;git clone https://github.com/s-matyukevich/raspberry-pi-os
&lt;span class="nb"&gt;cd&lt;/span&gt; raspberry-pi-os
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Our code is in &lt;code&gt;src/lesson01&lt;/code&gt;. Take some time to go through the line-by-line documentation at &lt;a href="https://github.com/s-matyukevich/raspberry-pi-os/blob/master/docs/lesson01/rpi-os.md"&gt;docs/lesson01&lt;/a&gt; which also explains our motivation and the code structure.&lt;/p&gt;
&lt;p&gt;Open each and every file in the &lt;code&gt;src&lt;/code&gt; directory to understand how they all fit together. Take a look at &lt;code&gt;./Makefile&lt;/code&gt; to understand the build process.&lt;/p&gt;
&lt;p&gt;We are now ready to build our code and run it on QEMU.&lt;/p&gt;
&lt;div class="bash highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;make clean &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; make
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This generates our kernel image &lt;code&gt;kernel8.img&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Our job now is simple. Run this kernel image on our emulated system with QEMU. For this, use the following command.&lt;/p&gt;
&lt;div class="bash highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;#This sets uart to null and connects mini-uart to stdio, booting our kernel image&lt;/span&gt;
qemu-system-aarch64 -M raspi3 -serial null -serial mon:stdio -nographic -kernel kernel8.img
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This should give us the output &lt;code&gt;Hello, world!&lt;/code&gt; followed by echoing any input characters.&lt;/p&gt;
&lt;p&gt;Congratulations, you just made your first bare-metal application.&lt;/p&gt;</content><category term="tech"></category></entry></feed>